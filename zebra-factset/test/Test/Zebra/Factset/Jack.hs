{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE NoImplicitPrelude #-}
module Test.Zebra.Factset.Jack (

  -- * Zebra.Factset.Block
    jBlock
  , jYoloBlock
  , jBlockEntity
  , jBlockAttribute
  , jBlockIndex
  , jTombstone

  -- * Zebra.Factset.Data
  , jBinaryVersion
  , jEntityId
  , jEntityHashId
  , jAttributeId
  , jAttributeName
  , jFactsetTime
  , jFactsetDay
  , jFactsetId

  -- * Zebra.Factset.Entity
  , jEntity
  , jAttribute

  -- * Zebra.Factset.Fact
  , jFacts
  , jFact
  ) where

import           Data.ByteString (ByteString)
import qualified Data.ByteString.Char8 as Char8
import qualified Data.List as List
import qualified Data.Thyme.Calendar as Thyme
import qualified Data.Vector as Boxed
import qualified Data.Vector.Storable as Storable
import qualified Data.Vector.Unboxed as Unboxed

import           Disorder.Corpus (muppets, southpark)
import           Disorder.Jack (Jack, mkJack, shrinkTowards, sized, scale)
import           Disorder.Jack (elements, arbitrary, choose, chooseInt)
import           Disorder.Jack (oneOf, listOf, listOfN, justOf, maybeOf)

import           P

import qualified Prelude as Savage

import           Test.Zebra.Jack

import qualified Test.QuickCheck as QC
import           Test.QuickCheck.Instances ()

import           Text.Printf (printf)

import           Zebra.Factset.Block
import qualified Zebra.Factset.Data as Factset
import           Zebra.Factset.Entity
import           Zebra.Factset.Fact

import           Zebra.Table.Data
import qualified Zebra.Table.Schema as Schema
import qualified Zebra.Table.Striped as Striped

jEntityId :: Jack Factset.EntityId
jEntityId =
  let
    mkEnt :: ByteString -> Int -> Factset.EntityId
    mkEnt name num =
      Factset.EntityId $ name <> Char8.pack (printf "-%03d" num)
  in
    oneOf [
        mkEnt <$> elements southpark <*> pure 0
      , mkEnt <$> elements southpark <*> chooseInt (0, 999)
      ]

jEntityHashId :: Jack (Factset.EntityHash, Factset.EntityId)
jEntityHashId =
  let
    hash eid =
      Factset.EntityHash $
        Factset.unEntityHash (Factset.hashEntityId eid) `mod` 10
  in
    (\eid -> (hash eid, eid)) <$> jEntityId

jAttributeId :: Jack Factset.AttributeId
jAttributeId =
  Factset.AttributeId <$> choose (0, 10000)

jAttributeName :: Jack Factset.AttributeName
jAttributeName =
  Factset.AttributeName <$> oneOf [elements muppets, arbitrary]

jFactsetTime :: Jack Factset.Time
jFactsetTime =
  oneOf [
      Factset.Time <$> choose (0, 5)
    , Factset.fromDay <$> jFactsetDay
    ]

jFactsetDay :: Jack Thyme.Day
jFactsetDay =
  justOf . fmap Thyme.gregorianValid $
    Thyme.YearMonthDay
      <$> jFactsetYear
      <*> chooseInt (1, 12)
      <*> chooseInt (1, 31)

jFactsetYear :: Jack Thyme.Year
jFactsetYear =
  mkJack (shrinkTowards 2000) $ QC.choose (1600, 3000)

jFactsetId :: Jack Factset.FactsetId
jFactsetId =
  oneOf [
      Factset.FactsetId <$> choose (0, 5)
    , Factset.FactsetId <$> choose (0, 100000)
    ]

jBlock :: Jack Block
jBlock = do
  schemas <- listOfN 0 5 jColumnSchema
  facts <- jFacts schemas
  pure $
    case blockOfFacts (Boxed.fromList schemas) (Boxed.fromList facts) of
      Left x ->
        Savage.error $ "Test.Zebra.Jack.jBlock: invariant failed: " <> show x
      Right x ->
        x

-- The blocks generated by this can contain data with broken invariants.
jYoloBlock :: Jack Block
jYoloBlock = do
  sized $ \size ->
    Block
      <$> (Boxed.fromList <$> listOfN 0 (size `div` 5) jBlockEntity)
      <*> (Unboxed.fromList <$> listOfN 0 (size `div` 5) jBlockIndex)
      <*> (Boxed.fromList <$> listOfN 0 (size `div` 5)
            (fmap (Striped.Array DenyDefault) . jStripedColumn =<< chooseInt (0, size `div` 5)))

jBlockEntity :: Jack BlockEntity
jBlockEntity =
  uncurry BlockEntity
    <$> jEntityHashId
    <*> (Unboxed.fromList <$> listOf jBlockAttribute)

jBlockAttribute :: Jack BlockAttribute
jBlockAttribute =
  BlockAttribute
    <$> jAttributeId
    <*> choose (0, 1000000)

jBlockIndex :: Jack BlockIndex
jBlockIndex =
  BlockIndex
    <$> jFactsetTime
    <*> jFactsetId
    <*> jTombstone

jEntity :: Jack Entity
jEntity =
  uncurry Entity
    <$> jEntityHashId
    <*> (Boxed.fromList <$> listOf jAttribute)

jAttribute :: Jack Attribute
jAttribute = do
  (ts, ps, bs) <- List.unzip3 <$> listOf ((,,) <$> jFactsetTime <*> jFactsetId <*> jTombstone)
  Attribute
    <$> pure (Storable.fromList ts)
    <*> pure (Storable.fromList ps)
    <*> pure (Storable.fromList bs)
    <*> jStripedArray (List.length ts)

jTombstone :: Jack Tombstone
jTombstone =
  elements [
      NotTombstone
    , Tombstone
    ]


jFacts :: [Schema.Column] -> Jack [Fact]
jFacts schemas =
  fmap (List.sort . List.concat) .
  scale (`div` max 1 (length schemas)) $
  zipWithM (\e a -> listOf $ jFact e a) schemas (fmap Factset.AttributeId [0..])

jFact :: Schema.Column -> Factset.AttributeId -> Jack Fact
jFact schema aid =
  uncurry Fact
    <$> jEntityHashId
    <*> pure aid
    <*> jFactsetTime
    <*> jFactsetId
    <*> (strictMaybe <$> maybeOf (jLogicalValue schema))
